import argparse
import sys

import settings
from code_source.code_source_service import CodeSourcesService
from borrowing_analyzer import BorrowingAnalyzer
from database.database_service import DataBaseService


class Main:
    @staticmethod
    def main() -> int:
        arg_parser = argparse.ArgumentParser(description='Vulnerabilities borrowing analyzer')
        args = Main.get_args(arg_parser)

        if args.print_config:
            Main.act_print_config()
            return 0

        compared_file1, compared_file2 = args.compare_files
        if compared_file1 and compared_file2:
            Main.act_compare_two_files(str(compared_file1), str(compared_file2))
            return 0
        if compared_file1 and not compared_file2 or not compared_file1 and compared_file2:
            arg_parser.print_help()
            return 0

        if args.not_save and args.force_save:
            arg_parser.print_help()
            return 0
        if args.file is None and args.dir is None:
            arg_parser.print_help()
            return 0
        if args.file and args.dir:
            arg_parser.print_help()
            return 0

        is_load_code_from_directory = False
        if args.dir:
            path = args.dir
            is_load_code_from_directory = True
        else:
            path = args.file

        # 0 - not save; 1 - save if isn't borrowed; 2 - save anyway
        save_mode = 1
        if args.not_save:
            save_mode = 0
        if args.force_save:
            save_mode = 2

        Main.act_find_vulnerabilities(save_mode, is_load_code_from_directory, path)
        return 0

    @staticmethod
    def get_args(arg_parser):
        arg_parser.add_argument('-c', '--compare-files', type=str, nargs=2, metavar=('FILE1', 'FILE2'),
                                help='compare two files')
        arg_parser.add_argument('-f', '--file', type=str, help='file with source code')
        arg_parser.add_argument('-d', '--dir', type=str, help='directory with source codes')
        arg_parser.add_argument('--not-save', help='don\'t save the code to the code base', action='store_true')
        arg_parser.add_argument('--force-save', help='save the code to the code base anyway', action='store_true')
        arg_parser.add_argument('--print-config', help='print configs', action='store_true')
        return arg_parser.parse_args()

    @staticmethod
    def act_print_config():
        print(f'''Max borrowing score:
Text view score:\t\t{settings.MAX_TEXT_SCORE}
GED syntax tree view score:\t{settings.MAX_GED_TREE_SCORE}
Jaccard syntax tree view score:\t{settings.MAX_JACCARD_TREE_SCORE}
''')

    @staticmethod
    def act_find_vulnerabilities(save_mode: int, is_load_code_from_directory: bool, path: str):
        has_error, code_sources = CodeSourcesService.get_enriched_code_sources_by_path(path,
                                                                                       is_load_code_from_directory)
        if has_error:
            print('Problems with files loading', file=sys.stderr)
            return

        if not code_sources:
            print('No files in directory', file=sys.stderr)
            return

        database = DataBaseService(settings.DB_NAME)
        is_success = database.connect()
        if not is_success:
            print('Problems with database connection', file=sys.stderr)
            return

        rows_count = database.rows_count()
        if rows_count < 1 and save_mode != 0:
            for code_source in code_sources:
                row_to_save = code_source.to_database_row()
                database.insert_row(row_to_save)
            print('Saved some sources', file=sys.stderr)
            return
        elif rows_count < 1:
            print('There are not rows in database, do not use --not-save', file=sys.stderr)
            return

        limit = settings.BATCH_SELECT_DB_LIMIT
        offset = 0
        rows = database.select_rows(offset, limit)
        analyze_results = []
        all_not_borrowed_codes = []
        while rows:
            results, not_borrowed_codes = BorrowingAnalyzer.analyze_many(code_sources, rows)
            analyze_results.extend(results)
            all_not_borrowed_codes.extend(not_borrowed_codes)
            offset += limit
            rows = database.select_rows(offset, limit)

        for result in analyze_results:
            print(result)

        if save_mode == 1:
            for code_source in all_not_borrowed_codes:
                row_to_save = code_source.to_database_row()
                database.insert_row(row_to_save)
        if save_mode == 2:
            for code_source in code_sources:
                row_to_save = code_source.to_database_row()
                database.insert_row(row_to_save)

    @staticmethod
    def act_compare_two_files(path_file1: str, path_file2: str):
        has_error, code_source1 = CodeSourcesService.get_enriched_code_sources_by_path(path_file1)
        if has_error:
            print('Problems with files loading', file=sys.stderr)
            return

        has_error, code_source2 = CodeSourcesService.get_enriched_code_sources_by_path(path_file2)
        if has_error:
            print('Problems with files loading', file=sys.stderr)
            return

        results = BorrowingAnalyzer.analyze_two_code_sources(code_source1.pop(), code_source2.pop())
        print(results)
        return


if __name__ == '__main__':
    exit(Main.main())
